<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebRTC Manual Exchange (with ICE)</title>
    <style>
      body { font-family: Arial, sans-serif; padding:20px; }
      video { width: 100%; max-width: 320px; height: auto; background: #000; }
      .videos { display: flex; flex-direction: column; gap:20px; }
      @media(min-width:700px){ .videos { flex-direction: row; } }
      textarea { width:100%; height:150px; margin-top:12px; }
      button { margin: 6px; }
    </style>
  </head>
  <body>
    <h1>WebRTC через файлы (Offer/Answer + ICE)</h1>

    <div class="videos">
      <div>
        <h3>Местное</h3>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
      <div>
        <h3>Удалённое</h3>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>

    <div>
      <button onclick="createOffer()">Создать Offer (файл)</button>
      <button onclick="createAnswer()">Создать Answer (файл)</button>
      <input type="file" id="fileInput" />
      <button onclick="loadFile()">Загрузить файл (Offer/Answer)</button>
    </div>

    <script>
      let pc;
      let candidates = [];
      const localVideo = document.getElementById('localVideo');
      const remoteVideo = document.getElementById('remoteVideo');

      async function init(){
        if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
          alert('⚠️ Для работы камеры/микрофона нужен HTTPS или localhost');
          return;
        }

        pc = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        pc.ontrack = (e) => {
          remoteVideo.srcObject = e.streams[0];
        };

        pc.onicecandidate = (e) => {
          if(e.candidate){
            candidates.push(e.candidate.toJSON());
          }
        };

        try {
          const stream = await navigator.mediaDevices.getUserMedia({audio:true, video:true});
          localVideo.srcObject = stream;
          stream.getTracks().forEach(track => pc.addTrack(track, stream));
        } catch(err) {
          alert('Ошибка доступа: ' + err.message);
        }
      }
      init();

      function download(data, filename){
        const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      async function createOffer(){
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await waitForIce();
        download({sdp: pc.localDescription, candidates}, 'offer.json');
      }

      async function createAnswer(){
        const fileInput = document.getElementById('fileInput');
        if(fileInput.files.length === 0){
          alert('Сначала загрузите Offer файл');
          return;
        }
        const offerData = JSON.parse(await fileInput.files[0].text());
        await pc.setRemoteDescription(new RTCSessionDescription(offerData.sdp));
        for(const c of offerData.candidates){
          try{ await pc.addIceCandidate(c); }catch(e){ console.warn(e); }
        }
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await waitForIce();
        download({sdp: pc.localDescription, candidates}, 'answer.json');
      }

      async function loadFile(){
        const fileInput = document.getElementById('fileInput');
        if(fileInput.files.length === 0){
          alert('Выберите файл Offer/Answer');
          return;
        }
        const data = JSON.parse(await fileInput.files[0].text());
        await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
        for(const c of data.candidates){
          try{ await pc.addIceCandidate(c); }catch(e){ console.warn(e); }
        }
        alert('Удалённое описание и ICE применены');
      }

      function waitForIce(){
        return new Promise(resolve => {
          if(pc.iceGatheringState === 'complete') resolve();
          else {
            pc.onicegatheringstatechange = () => {
              if(pc.iceGatheringState === 'complete') resolve();
            };
          }
        });
      }
    </script>

    <p><strong>Как пользоваться:</strong></p>
    <ol>
      <li>Открой страницу на обоих устройствах (по HTTPS).</li>
      <li>Устройство A: нажать «Создать Offer» → получить <code>offer.json</code>.</li>
      <li>Устройство B: загрузить offer.json → нажать «Создать Answer» → получить <code>answer.json</code>.</li>
      <li>Устройство A: загрузить answer.json → соединение установится.</li>
    </ol>
  </body>
</html>
